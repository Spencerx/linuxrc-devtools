#! /usr/bin/perl

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#
# This script is maintained at https://github.com/openSUSE/ssob
#
# If you're in another project, this is just a copy.
# You may update it to the latest version from time to time...
#
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

use strict;

use Getopt::Long;

use Data::Dumper;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse = 1;
$Data::Dumper::Indent = 1;

sub usage;
sub changelog_outdated;
sub get_github_project;
sub get_version;
sub get_tags;
sub get_log;
sub is_formatted_tag;
sub get_branch;
sub choose_tags;
sub add_head_tag;
sub tags_to_str;
sub format_log;
sub format_all_logs;
sub add_line_breaks;
sub format_date_obs;
sub format_date_iso;
sub raw_date_to_s;

usage 0 if !@ARGV;

my @changelog_deps = qw ( .git/HEAD .git/refs/heads .git/refs/tags );

my $branch;
my $current_version;
my @tags;
my @all_tags;
my $config;

my $opt_log;
my $opt_version;
my $opt_branch;
my $opt_update;
my $opt_file;
my $opt_start;
my $opt_max;
my $opt_width = 66;
my $opt_width_fuzz = 8;
my $opt_sep_width = 68;
my $opt_format = 'internal';		# obs, internal

GetOptions(
  'help'          => sub { usage 0 },
  'version'       => \$opt_version,
  'branch'        => \$opt_branch,
  'update'        => \$opt_update,
  'start=s'       => \$opt_start,
  'format=s'      => \$opt_format,
  'max=i'         => \$opt_max,
  'width=i'       => \$opt_width,
  'fuzz=i'        => \$opt_width_fuzz,
  'log|changelog' => \$opt_log,
) || usage 1;

# ensure we are used correctly
usage 1 if @ARGV > 1 || !($opt_log || $opt_version || $opt_branch);
$opt_file = @ARGV ? shift : '-';

die "no git repo\n" unless -d ".git";

# if update option has been give write changelog only if git refs are newer
exit 0 if $opt_update && $opt_file ne '-' && -f($opt_file) && !changelog_outdated($opt_file);

$opt_max = 2 if $opt_version || $opt_branch;

# gather some data
get_github_project;
get_branch;
get_log;
get_tags;
choose_tags;
add_head_tag;
get_version;

# just print current branch
if($opt_branch) {
  open my $f, ">$opt_file";
  print $f $config->{branch} ? $config->{branch} : "master", "\n";
  close $f;

  exit 0;
}

# just print current version
if($opt_version) {
  open my $f, ">$opt_file";
  print $f "$config->{version}\n";
  close $f;

  exit 0;
}

# set start tag
if($opt_start) {
  my $x = is_formatted_tag $opt_start;
  die "$opt_start: not a valid start tag\n" if !$x;
  $x->{branch} = $config->{branch} if !$x->{branch};
  $config->{start} = $x;
}

format_all_logs;

# print Dumper $config;

open my $f, ">$opt_file";

print $f $_->{formatted} for @{$config->{log}};

close $f;

exit 0;


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub usage
{
  my $err = shift;

  print <<"  usage";
Usage: git2log [OPTIONS] [FILE]
Create changelog and project version from git repo.
  --changelog         Write changelog to FILE.
  --version           Write version number to FILE.
  --branch            Write current branch to FILE.
  --start START_TAG   Start with tag START_TAG.
  --max N             Write at most MAX long entries.
  --update            Write changelog or version only if FILE is outdated.
  --format FORMAT     Write log using FORMAT. Supported FORMATs are 'internal' (default) and 'obs'.
  --width WIDTH       Reformat log entries to be max WIDTH chars wide.
  --fuzz FUZZ         Allow log lines to be up to FUZZ chars longer as WIDTH to avoid
                      line breaks leaving tiny bits on the last line.
  --help              Print this help text.
  usage

  exit $err;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# changelog_outdated(filename)
#
# Return 1 if changelog is newer than the last git repo change and should be updated.
#
# Relies on global var @changelog_deps.
#
sub changelog_outdated
{
  my $file = $_[0];

  my $changelog_time = (stat $file)[9];

  return 1 if !defined $changelog_time;

  for (@changelog_deps) {
    return 1 if (stat)[9] > $changelog_time;
  }

  return 0;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Get github project name.
#
sub get_github_project
{
  if(`git config remote.origin.url` =~ m#github.com[:/]+(\S+/\S+)#) {
    $config->{github_project} = $1;
    $config->{github_project} =~ s/\.git$//;
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub get_version
{
  $config->{version} = "0.0";

  my $tag = $config->{log}[0]{tags}[0];

  if($tag->{version}) {
    $config->{version} = $tag->{version};
    $config->{branch} = $tag->{branch};
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Parses $config->{raw_log} and extracts tag names.
#
# Commit ids for tags are stored in $config->{tags} and (reversed) in
# $config->{commits} (holds array of tags!).
#
# get_tags()
#
sub get_tags
{
  my $log_entry;

  for (@{$config->{raw_log}}) {
    if(/^commit (\S+)( \((.*)\))?/) {
      my $commit = $1;
      my $tag_list = $3;
      my $xtag;

      for my $t (split /, /, $tag_list) {
        if($t =~ /tag: (\S+)/) {
          my $tag = $1;
          my $x = is_formatted_tag $tag;
          push @$xtag, $x if $x;
        }
      }

      if($xtag) {
        if($log_entry) {
          push @{$config->{log}}, $log_entry;
          last if $opt_max && @{$config->{log}} >= $opt_max;
        }
        $log_entry = { commit => $commit, tags => $xtag };
      }
      else {
        $log_entry = { commit => $commit } if !$log_entry;
      }
    }

    push @{$log_entry->{lines}}, $_ if $log_entry;
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Read git log and store lines as array in $config->{raw_log} (no trailing newlines).
#
# get_log()
#
sub get_log
{
  chomp(@{$config->{raw_log}} = `git log --pretty=medium --date=raw --topo-order --decorate`);
  # chomp(@{$config->{raw_log}} = `cat foo`);
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Parse tag and return hash ref with branch and version number parts or
# undef if it doesn't match.
#
# This expects tags of the form "VERSION" or "BRANCH-VERSION" where VERSION
# consists of decimal numbers separated by dots '.' and BRANCH can be any
# string (notably it doesn't have to be the name of any existing branch).
#
# hash_ref = is_formatted_tag(tag_name)
#
sub is_formatted_tag
{
  if($_[0] =~ /^((.+)-)?((\d+\.)*\d+)$/) {
    return { branch => $2, version => $3 }
  }

  return undef;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Get currently active branch and store in $config->{branch}.
#
# get_branch()
#
sub get_branch
{
  chomp(my $branch = `git rev-parse --abbrev-ref HEAD`);

  $branch = "" if $branch eq 'master';

  $config->{branch} = $branch;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub tag_sort
{
  my ($x, $y);

  $x = length $a->{version};
  $y = length $b->{version};

  # longer version number first
  return $y <=> $x if $y <=> $x;

  return $a->{branch} cmp $b->{branch};
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#
# str = tag_to_str(tag_ref)
#
sub tag_to_str
{
  my $tag = $_[0];
  my $str;

  $str = "$tag->{branch}-" if $tag->{branch} ne "";
  $str .= $tag->{version};

  return $str;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#
# str = tags_to_str(tag_array_ref)
#
sub tags_to_str
{
  my $tags = $_[0];
  my $str;

  for my $t (@$tags) {
    $str .= ", " if $str;
    $str .= tag_to_str $t;
  }

  return "($str)";
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#
# choose_tags()
#
sub choose_tags
{
  my $branch = $config->{branch};

  for my $x (@{$config->{log}}) {
    # printf "# %s\n", tags_to_str($x->{tags});

    # no tag info? -> ignore
    next if !$x->{tags};

    # single tag? -> remember branch info
    if(@{$x->{tags}} == 1) {
      $branch = $x->{tags}[0]{branch};
      next;
    }

    # several tags? -> choose one

    # any with current branch name?
    my @t = grep { $_->{branch} eq $branch } @{$x->{tags}};

    # no? -> choose among all
    @t = @{$x->{tags}} if @t == 0;

    # prefer longest version number, then alphanumerically smallest branch name
    @t = sort tag_sort @t;

    $branch = $t[0]{branch};
    $x->{tags} = [ $t[0] ];

    # printf "X %s\n", tags_to_str($x->{tags});
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Suggest tag for HEAD if there isn't one.
#
# Basically, use branch + version from most recent tag and increment version.
#
# add_head_tag()
#
sub add_head_tag
{
  return if @{$config->{log}} < 2;

  return if $config->{log}[0]{tags};

  my $tag = { %{$config->{log}[1]{tags}[0]} };

  $tag->{version} =~ s/(\d+)$/$1 + 1/e;

  $config->{log}[0]{tags}[0] = $tag;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub format_all_logs
{
  for (@{$config->{log}}) {
    if($config->{start}) {
      # stop if we meet the start tag
      last if grep { tag_to_str($config->{start}) eq tag_to_str($_) } @{$_->{tags}};
    }
    format_log $_;
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub format_log
{
  my $log = $_[0];

  my $merge;
  my $commit;
  my $saved_commit;
  my $commits;

  for (@{$log->{lines}}) {
    if(/^commit (\S+)/) {
      $commit = { ref => $1 };
      push @{$commits}, $commit;

      if(
        $merge &&
        $merge->{merge_end} eq substr($commit->{ref}, 0, length($merge->{merge_end}))
      ) {
        undef $merge;
      }

      if($merge) {
        $commit->{merge_ref} = $merge->{ref};
        $commit->{date} = $merge->{date};
        # add to all commits so it's not lost when we re-arrange
        $commit->{merge_msg} = $merge->{msg} if $merge->{msg};
        # saved entry no longer needed
        undef $saved_commit;
      }

      next;
    }

    if(/^Merge: (\S+)/) {
      if($commit) {
        $merge = { merge_end => $1, ref => $commit->{ref} } unless $merge;
        $saved_commit = pop @{$commits};
      }
      undef $commit;
      next;
    }

    if(/^Date:\s+(\S.*)/) {
      if($commit) {
        $commit->{date} = $1 if !$commit->{date};
      }
      elsif($merge) {
        $merge->{date} = $1 if !$merge->{date};
      }
      next;
    }

    if(/^Author:\s+(\S.*)/) {
      $commit->{author} = $1 if $commit;
      $merge->{author} = $1 if $merge && !$merge->{author};
      next;
    }

    if($commit) {
      push @{$commit->{lines}}, $_ if s/^    //;
    }
    elsif($merge && !$merge->{msg}) {
      if(/^    Merge pull request (#\d+) from (\S+)/) {
        if($config->{github_project}) {
          $merge->{msg} = "merge gh#$config->{github_project}$1";
        }
        else {
          $merge->{msg} = "merge pr $2";
        }
      }
      elsif(/^    Merge branch '([^']+)'/) {
        $merge->{msg} = "merge branch $1";
      }
    }
  }

  # it can happen that there's a lonely merge commit left at the end
  if($merge && $saved_commit) {
    $saved_commit->{merge_ref} = $merge->{ref};
    $saved_commit->{date} = $merge->{date};
    $saved_commit->{author} = $merge->{author};
    $saved_commit->{merge_msg} = $merge->{msg} if $merge->{msg};
    $saved_commit->{formatted} = [];

    push @{$commits}, $saved_commit;
  }

  # step 1
  # - leave only first paragraph or paragraphs starting with '@log@' or '@+log@'
  # - tag commits that have a '@log@' tag

  my $tagged_merges = {};

  for my $commit (@$commits) {
    my $para_cnt = 0;
    for (@{$commit->{lines}}) {
      $para_cnt++ if $_ eq "";
      $para_cnt = 0 if /^\@\+log\@/;
      if(/^\@log\@/) {
        $para_cnt = 0;
        $commit->{clear} = 1;
        $tagged_merges->{$commit->{merge_ref}} = 1 if $commit->{merge_ref};
      }
      $_ = undef if $para_cnt;
    }
  }

  # step 2
  # - clean up tagged commits or commits belonging to tagged merges

  for my $commit (@$commits) {
    next unless $commit->{clear} || $tagged_merges->{$commit->{merge_ref}};
    for (@{$commit->{lines}}) {
      last if /^\@\+?log\@/;
      $_ = undef;
    }
  }

  # step 3
  # join lines

  for my $commit (@$commits) {
    my $lines;
    my $line;

    for (@{$commit->{lines}}) {
      next if $_ eq "";
      if(
        s/^\s*[+\-][\-\s]*// ||
        s/^\@\+?log\@// ||
        $line eq ""
      ) {
        s/^\s*//;
        push @$lines, $line if $line ne "";
        $line = $_;
      }
      else {
        s/^\s*//;
        $line .= " " if $line ne "";
        $line .= $_;
      }
    }
    push @$lines, $line if $line ne "";

    $commit->{formatted} = $lines if $lines;
  }

  # step 4
  # fix small glitches

  for my $commit (@$commits) {
    next unless $commit->{formatted};
    for (@{$commit->{formatted}}) {
      s/(fate|bnc|bsc)\s*(#\d+)/\L$1\E$2/ig;
    }
  }

  # step 5
  # - add merge info at the top

  my $merge_logged;

  for my $commit (@$commits) {
    next unless $commit->{formatted};

    if($commit->{merge_ref} && !$merge_logged->{$commit->{merge_ref}}) {
      $merge_logged->{$commit->{merge_ref}} = 1;
      if($commit->{merge_msg}) {
        unshift @{$commit->{formatted}}, $commit->{merge_msg};
      }
    }
  }

  # step 6
  # join commit messages with same date & author

  my $commit0;

  for my $commit (@$commits) {
    next if !$commit->{formatted};
    $commit0 = $commit, next if !$commit0;

    if(
      # $commit->{merge_ref} eq $commit0->{merge_ref} &&
      (
        $commit->{author} eq $commit0->{author} &&
        $commit->{date} eq $commit0->{date}
      )
      || $opt_format eq 'internal'
    ) {
      unshift @{$commit0->{formatted}}, @{$commit->{formatted}};
      delete $commit->{formatted};
    }
  }

  # step 7
  # - add version tag at the end of the first log entry

  for my $commit (@$commits) {
    next unless $commit->{formatted};

    if($opt_format eq 'obs') {
      push @{$commit->{formatted}}, $log->{tags}[0]{version};
    }
    else {
      # push @{$commit->{formatted}}, tag_to_str($log->{tags}[0]);
    }

    last;
  }

  # step 8
  # add line breaks

  for my $commit (@$commits) {
    next unless $commit->{formatted};
    for (@{$commit->{formatted}}) {
      $_ = add_line_breaks $_;
    }
  }

  # step 9
  # generate final log message

  my $formated_log;

  for my $commit (@$commits) {
    next unless $commit->{formatted} && @{$commit->{formatted}};

    if($opt_format eq 'obs') {
      $formated_log .= "-" x $opt_sep_width . "\n";
      $formated_log .= format_date_obs($commit->{date});
    }
    else {
      $formated_log .= format_date_iso($commit->{date});
    }
    if($opt_format eq 'obs') {
      my $auth = $commit->{author};
      $auth =~ s/^.*<//;
      $auth =~ s/>.*$//;
      # replace non-suse e-mail addresses with a generic one
      if($auth !~ /\@(suse\.(com|cz|de)|opensuse\.org)$/) {
        $auth = 'opensuse-packaging@opensuse.org'
      }
      $formated_log .= " - $auth\n\n";
    }
    else {
      $formated_log .= ":\t" . tag_to_str($log->{tags}[0]) . "\n";
    }

    for (@{$commit->{formatted}}) {
      s/^/\t/mg if $opt_format eq 'internal';
      $formated_log .= "$_\n";
    }

    $formated_log .= "\n";
  }

  $log->{formatted} = $formated_log;

  # print Dumper($commits);
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub add_line_breaks
{
  my @words = split /\s+/, @_[0];
  my $remaining_len = length(join '', @words);

  my $str = shift(@words);
  my $len = length $str;

  my $next_len;
  my $word_len;

  for (@words) {
    $word_len = length;
    $remaining_len -= $word_len;
    $next_len = $len + $word_len + 1;
    if(
      $next_len >= $opt_width &&
      $next_len + $remaining_len + 1 >= $opt_width + $opt_width_fuzz
    ) {
      $str .= "\n  $_";
      $len = $word_len;
    }
    else {
      $str .= " $_";
      $len += $word_len + 1;
    }
  }

  return "- " . $str;
}


sub raw_date_to_s
{
  return (split / /, $_[0])[0];
}


# Tue Dec 31 23:59:59 UTC 2016
sub format_date_obs
{
  my @d = gmtime(raw_date_to_s($_[0]));

  return
    qw(Sun Mon Tue Wed Thu Fri Sat)[$d[6]] . " " .
    qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec)[$d[4]] . " " .
    $d[3] . " " .
    sprintf("%02d:%02d:%02d", $d[2], $d[1], $d[0]) . " UTC " .
    (1900 + $d[5]);
}


# 2016-12-31
sub format_date_iso
{
  my @d = gmtime(raw_date_to_s($_[0]));

  return sprintf("%04d-%02d-%02d", 1900 + $d[5], $d[4] + 1, $d[3]);
}

